C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LNK_EMU_ADJ
OBJECT MODULE PLACED IN .\Lnk_EMU_Adj.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\C_Source\S1_HardDrv\V9811A_EMU\Lnk_EMU_Adj.c LARGE WARNINGLEVEL(1) BROWS
                    -E INCDIR(..\C_Source\S0_System;..\C_Source\S1_HardDrv;..\C_Source\S2_MyLib;..\C_Source\S3_ApiPlat;..\C_Source\S4_ApiUser
                    -;..\C_Source\S5_ApiProtocol;..\C_Source\S6_MyIncludes;..\C_Source\S1_HardDrv\V9811A_EMU;..\C_Source\S1_HardDrv\V9811A_MC
                    -U;..\C_Source\S1_HardDrv\E2P_24CXXX) DEBUG OBJECTEXTEND PRINT(.\Lnk_EMU_Adj.lst) OBJECT(.\Lnk_EMU_Adj.obj)

line level    source

   1          /*
   2          *****************Copyright (c)*************************************
   3          **      Hangzhou Xili Watthour Meter Manufacture Co., Ltd. 
   4          **--------------file info--------------------------------------------
   5          **name                  : Lnk_EMU_Adj.c
   6          **Author                : maji
   7          **date                  : 2016-04-20 
   8          **description   : G80F92XDµÄEMU¼ÆÁ¿Ä£¿éÁ´Â·²ãÐ£±í´¦ÀíC´úÂë
   9          **note                  : MCU- G80F92XD £¬MERTER FOR DL06A
  10          **--------------------Version History -------------------------------------
  11          ** NO. Date         Ver      By         Description 
  12          **==============================================================
  13          ** 1   2016-04-20   v01.00   sosomj     1. frist version                             
  14          **
  15          **==============================================================
  16          */
  17          
  18          #include <MyIncludes_H.h>
  19          
  20          
  21          
  22          ST_EMU_ADJ_PARAM  gs_adj_emu_param;
  23          ST_EMU_ADJ_VAR      gs_emu_adj_var;
  24          
  25          
  26          /*********************************************************************************************************
  27          **  Ð£±íÏà¹Ø²ÎÊý³õÊ¼»¯Ä¬ÈÏÊý¾Ý
  28          ********************************************************************************************************/
  29          const  ST_EMU_ADJ_PARAM  code   default_adj_emu_param_tab = 
  30          {
  31              86243328,  //uint32 w1gain;   //Í¨µÀ1¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  32              7,  //uint32 p1cal;           //Í¨µÀ1µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  33              0,  //uint32 watt1os;      //Í¨µÀ1ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  34              0,  //uint32 irms1os;      //Í¨µÀ1µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ  //
  35              3653512704,  //uint32 w2gain;         //Í¨µÀ2¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  36              7,  //uint32 p2cal;           //Í¨µÀ2µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  37              0,  //uint32 watt2os;      //Í¨µÀ2ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  38              0,  //uint32 irms2os;      //Í¨µÀ2µçÁ÷ÓÐÐ§ÖµÆ«ÖÃ  //
  39              0.1099405,  //uint32 vconst_val_ch1;   //Í¨µÀ1µôÁãÏßµçÑ¹¹Ì¶¨Öµ //    
  40              0.07784639,  //uint32 vconst_val_ch2;   //Í¨µÀ2µôÁãÏßµçÑ¹¹Ì¶¨Öµ //
  41              9.657958e-006,  //float vrms_xs;          //ÈËÎª¼ÆËãµÄµçÑ¹ÓÐÐ§ÖµÏµÊý  //
  42              0.0001168467,  //float i1rms_xs;         //ÈËÎª¼ÆËãµÄÍ¨µÀ1µçÁ÷ÓÐÐ§ÖµÏµÊý  //
  43              8.279879e-005,  //float i2rms_xs;         //ÈËÎª¼ÆËãµÄÍ¨µÀ2µçÁ÷ÓÐÐ§ÖµÏµÊý  //
  44              0,  //uint16     csck;  //Ð£ÑéºÍ //
  45          };
  46          
  47          const  ST_Adjust_CONST  code   cst_adj_const = 
  48          {
  49              C_Un*10,        //uint32 U_ref;       //²Î±ÈµçÑ¹Öµ£¬Á¿¸Ù0.1V  // 
  50              2*C_Ib*1000,     //uint32 I_ref;       //²Î±ÈµçÁ÷Öµ£¬Á¿¸Ù0.001A  //     
  51              INITGATEP,     //uint32 GATEP;    // ¼ÆÁ¿ÃÅÏÞÖµ //
  52              INITGATECP,   //uint32 C_GATECP;   // Ç±¶¯ÃÅÏÞÖµ //
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 2   

  53              REF_RMSPn,    // uint32 C_PCONST;   // ¶î¶¨¹¦ÂÊµÄÐ£×¼ºó±ê×¼Öµ//
  54              K_RMSP,         //float   Kim_Prms;          //ÓÐ¹¦¹¦ÂÊÓÐÐ§ÖµÏµÊý//   
  55          };
  56          
  57          
  58          const  EMU_CK_TAB  code   cst_emu_selfchck_tab[] = 
  59          {
  60              &gs_adj_emu_param.w1gain,            SCP,    //Í¨µÀ1¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  61              &gs_adj_emu_param.w2gain,            SCQ,    //Í¨µÀ2¹¦ÂÊÔöÒæ¼Ä´æÆ÷(ÓÐ¹¦ÎÞ¹¦Ê¹ÓÃÍ¬Ò»×é)  //
  62              &gs_adj_emu_param.p1cal,            PHCCtrl1,    //Í¨µÀ1µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  63              &gs_adj_emu_param.p2cal,            PHCCtrl2,    //Í¨µÀ2µçÑ¹µçÁ÷ÏàÎ»²¹³¥¼Ä´æÆ÷  //
  64              &gs_adj_emu_param.watt1os,            PARAPC,    //Í¨µÀ1ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  // 
  65              &gs_adj_emu_param.watt2os,            PARAQC,    //Í¨µÀ2ÓÐ¹¦¹¦ÂÊÆ«ÖÃ  //
  66          };
  67          
  68          const  EMU_CONST_CK_TAB  code   cst_emu_constchck_tab[] = 
  69          {
  70              INITGATEP,            GATEP,    //uint32 GATEP;    // ¼ÆÁ¿ÃÅÏÞÖµ //
  71              INITGATECP,          GATECP,    //uint32 C_GATECP;   // Ç±¶¯ÃÅÏÞÖµ //
  72              0,                         SCU,     // U32  µçÑ¹ÓÐÐ§Öµ±È²îÐ£ÕýÖµ //
  73              0,                         SCI1,     // U32  I1 µçÁ÷ÓÐÐ§Öµ±È²îÐ£ÕýÖµ//
  74              0,                         SCI2,     // U32  I2 µçÁ÷ÓÐÐ§Öµ±È²îÐ£ÕýÖµ//
  75          };
  76          
  77          /*********************************************************************************************************
  78          ** º¯ÊýÃû³Æ: Save_EMU_AdjParam
  79          ** ¹¦ÄÜÃèÊö: EMUÏà¹Ø²ÎÊýÐÞ¸ÄºóµÄ±£´æ¸üÐÂ´¦Àí
  80          ** Èë¿Ú²ÎÊý: ÎÞ
  81          ** ³ö¿Ú²ÎÊý: ÎÞ
  82          ********************************************************************************************************/
  83          void Save_EMU_AdjParam(void)
  84          {
  85   1          gs_adj_emu_param.csck =Lib_get_csck_int16u_num((uint8 *)&gs_adj_emu_param,(LEN_BLOCK70_EMU_PARAM_E2P-2
             -),CHECKWORD);
  86   1          mem_db_write(ADR_BLOCK70_EMU_PARAM_E2P, (uint8 *)&gs_adj_emu_param,(LEN_BLOCK70_EMU_PARAM_E2P-2),MEM_E
             -2P1); 
  87   1      }
  88          
  89          
  90          
  91          /*********************************************************************************************************
  92          ** º¯ÊýÃû³Æ: Save_EMU_AdjParam
  93          ** ¹¦ÄÜÃèÊö: EMUÏà¹Ø²ÎÊýÐÞ¸ÄºóµÄ±£´æ¸üÐÂ´¦Àí
  94          ** Èë¿Ú²ÎÊý: ÎÞ
  95          ** ³ö¿Ú²ÎÊý: ÎÞ
  96          ********************************************************************************************************/
  97          void Get_EMU_AdjParam(void)
  98          {
  99   1         uint16  csck_u16;
 100   1         
 101   1          Lib_Set_String((uint8 *)&gs_adj_emu_param,0,sizeof(gs_adj_emu_param));
 102   1          //RAM Êý¾Ý¼ì²é  //
 103   1          csck_u16 =Lib_get_csck_int16u_num((uint8 *)&gs_adj_emu_param,(LEN_BLOCK70_EMU_PARAM_E2P-2),CHECKWORD);
 104   1          if(csck_u16 != gs_adj_emu_param.csck)
 105   1          {
 106   2              mem_read((uint8 *)&gs_adj_emu_param, ADR_BLOCK70_EMU_PARAM_E2P, LEN_BLOCK70_EMU_PARAM_E2P, MEM_E2P
             -1);
 107   2          }
 108   1      }
 109          
 110          
 111          /*********************************************************************************************************
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 3   

 112          ** º¯ÊýÃû³Æ: Check_EMU_AdjParam
 113          ** ¹¦ÄÜÃèÊö: EMU¼Ä´æÆ÷Ð£Ñé
 114          ** Èë¿Ú²ÎÊý: ÎÞ
 115          ** ³ö¿Ú²ÎÊý: ÎÞ
 116          ********************************************************************************************************/
 117          void Check_EMU_AdjParam(void)
 118          {
 119   1         ST_U32_U08 regval;
 120   1         uint8 i;
 121   1         EMU_CK_TAB tmp_tab;
 122   1         EMU_CONST_CK_TAB  tmp_const_tab;
 123   1      
 124   1          // ¼ì²éRAMÄÚµÄÐ£±í²ÎÊýÊý¾Ý£¬Èç¹ûÐ£Ñé²»ÕýÈ·Ôò´ÓEEPROMÄÚ»ñÈ¡ //
 125   1          Get_EMU_AdjParam();   
 126   1      
 127   1          // ¹Ì¶¨ÖµÅäÖÃµÄÐ£±íÏà¹ØÊý¾Ý¼ì²é //    
 128   1          for(i=0;i<(dim(cst_emu_constchck_tab));i++)
 129   1          {
 130   2              tmp_const_tab.emuAdr = cst_emu_constchck_tab[i].emuAdr;
 131   2              tmp_const_tab.val = cst_emu_constchck_tab[i].val;
 132   2              regval.u32 = 0;
 133   2              regval.u32 = ReadMeterParaACK(tmp_const_tab.emuAdr);     //¼ÆÁ¿ÃÅÏÞÖµ¼ì²é  //
 134   2              if(regval.u32 != tmp_const_tab.val)
 135   2              {
 136   3                  regval.u32 = tmp_const_tab.val;
 137   3                  SetMeterCfgACK(regval.u32,tmp_const_tab.emuAdr);
 138   3              }  
 139   2          }
 140   1      
 141   1          // ¶ÁÈ¡´æ´¢Ð¾Æ¬ÄÚµÄÐ£±íÊý¾Ý½øÐÐ¼ì²é //
 142   1          for(i=0;i<(dim(cst_emu_selfchck_tab));i++)
 143   1          {
 144   2              tmp_tab.emuAdr = cst_emu_selfchck_tab[i].emuAdr;
 145   2              tmp_tab.ramAdr = cst_emu_selfchck_tab[i].ramAdr;
 146   2              regval.u32 = 0;
 147   2              regval.u32= ReadMeterParaACK(tmp_tab.emuAdr);
 148   2              if((tmp_tab.emuAdr==PHCCtrl1) ||(tmp_tab.emuAdr==PHCCtrl2))
 149   2              {
 150   3                  if(regval.B08[3] != (uint8)(*tmp_tab.ramAdr))
 151   3                  {
 152   4                      regval.u32 = (uint8)(*tmp_tab.ramAdr);
 153   4                      SetMeterCfgACK(regval.u32,tmp_tab.emuAdr);
 154   4                  }      
 155   3              }
 156   2              else
 157   2              {
 158   3                  if(regval.u32 != *tmp_tab.ramAdr)
 159   3                  {
 160   4                      regval.u32 = *tmp_tab.ramAdr;
 161   4                      SetMeterCfgACK(regval.u32,tmp_tab.emuAdr);
 162   4                  }
 163   3              }    
 164   2          }
 165   1      
 166   1      
 167   1          
 168   1      }
 169          
 170          /*********************************************************************************************************
 171          ** º¯ÊýÃû³Æ: Get_Original_Power
 172          ** ¹¦ÄÜÃèÊö: »ñÈ¡Ô­Ê¼¹¦ÂÊÖµ
 173          ** Èë¿Ú²ÎÊý: avr_times-Æ½¾ù´ÎÊý 
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 4   

 174          ** ³ö¿Ú²ÎÊý: ÎÞ         
 175          ********************************************************************************************************/
 176          uint32 Get_Original_Power(uint8 avr_times,uint8 ch)
 177          {
 178   1          uint32 val;
 179   1          uint8  i;
 180   1          uint32 aery_old;
 181   1          uint32 aery_val;
 182   1          uint32 avr_aery;
 183   1      
 184   1          CLRWDT();
 185   1      
 186   1          avr_aery=0;
 187   1          gs_emu_adj_var.sec_flg=FALSE; 
 188   1          for (i=0;i<avr_times;i++)
 189   1          {
 190   2              CLRWDT();
 191   2              while(gs_emu_adj_var.sec_flg==FALSE);
 192   2              gs_emu_adj_var.sec_flg=FALSE; 
 193   2              CLRWDT(); 
 194   2              if(ch==EMU_CH_L)
 195   2              {
 196   3                  val=ReadMeterParaACK(DATAIP);        
 197   3              }
 198   2              else
 199   2              {
 200   3                  val=ReadMeterParaACK(DATAIQ);          
 201   3              }
 202   2      
 203   2             if(val>=0x80000000)
 204   2             {
 205   3                val=~val+1;  
 206   3             }
 207   2      
 208   2             aery_old=val;
 209   2             avr_aery=avr_aery+aery_old;
 210   2          }   
 211   1      
 212   1          aery_val=avr_aery/avr_times;
 213   1          CLRWDT();
 214   1          NOP();
 215   1          return(aery_val);
 216   1      }               
 217          
 218          
 219          
 220          /*********************************************************************************************************
 221          ** º¯ÊýÃû³Æ: Get_Original_Irms
 222          ** ¹¦ÄÜÃèÊö: »ñÈ¡Ô­Ê¼µçÁ÷ÓÐÐ§ÖµÊý¾Ý
 223          ** Èë¿Ú²ÎÊý: avr_times-Æ½¾ù´ÎÊý 
 224          ** ³ö¿Ú²ÎÊý: ÎÞ         
 225          ********************************************************************************************************/
 226          uint32 Get_Original_Irms(uint8 avr_times,uint8 ch)
 227          {
 228   1          uint32 val;
 229   1          uint8  i;
 230   1          uint32 aery_old;
 231   1          uint32 aery_val;
 232   1          uint32 avr_aery;
 233   1      
 234   1          CLRWDT();
 235   1      
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 5   

 236   1          avr_aery=0;
 237   1          gs_emu_adj_var.sec_flg=FALSE; 
 238   1          for (i=0;i<avr_times;i++)
 239   1          {
 240   2              CLRWDT();
 241   2              while(gs_emu_adj_var.sec_flg==FALSE);
 242   2              gs_emu_adj_var.sec_flg=FALSE; 
 243   2              CLRWDT(); 
 244   2              if(ch==EMU_CH_L)
 245   2              {
 246   3                  val=ReadMeterParaACK(RMSII1);        
 247   3              }
 248   2              else
 249   2              {
 250   3                  val=ReadMeterParaACK(RMSII2);          
 251   3              }
 252   2      
 253   2             if(val>=0x80000000)
 254   2             {
 255   3                val=~val+1;  
 256   3             }
 257   2      
 258   2             aery_old=val;
 259   2             avr_aery=avr_aery+aery_old;
 260   2          }   
 261   1      
 262   1          aery_val=avr_aery/avr_times;
 263   1          CLRWDT();
 264   1          NOP();
 265   1          return(aery_val);
 266   1      }        
 267          
 268          
 269          /*=========================================================================================\n
 270          * @function_name: CalculateSC
 271          * @function_file: EnergyBottom.c
 272          * @ÃèÊö: ±È²î¼ÆËã¹«Ê½
 273          * 
 274          * 
 275          * @²ÎÊý: 
 276          * @param:CurValue  :µç±íÓÐ¹¦¹¦ÂÊÖµ
 277          * @param:TarValue  :±ê×¼±íÓÐ¹¦¹¦ÂÊÖµ
 278          * 
 279          * @·µ»Ø: 
 280          * @return: uint32 
 281          * @×÷Õß:   lwb (2012-03-08)
 282          * @±¸×¢: 
 283          *-------------------------------------------------------------------------------------------
 284          * @ÐÞ¸ÄÈË:  
 285          * @ÐÞ¸ÄÄÚÈÝ: 
 286          ===========================================================================================*/
 287          INT32U CalculateSC(INT32U CurValue,INT32U TarValue)
 288          {
 289   1          //  2016-5-20  mj //                
 290   1          INT32S s32_tmp0;
 291   1          double f_CurValue,f_TarValue,f_Error;
 292   1          double f_s32_tmp0,f_s32_tmp1,f_s32_tmp2,f_s32_tmp3;
 293   1      
 294   1          // »ñÈ¡µ±Ç°Îó²î  ((CurValue-TarValue)/TarValue )*100% //    
 295   1          f_CurValue = (double)CurValue;
 296   1          f_TarValue = (double)TarValue;
 297   1          f_Error = (f_CurValue-TarValue)*1.0/f_TarValue;
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 6   

 298   1      
 299   1              f_s32_tmp0 = 1.0/(1+f_Error);
 300   1      
 301   1              f_s32_tmp1 = f_s32_tmp0 - 1.0;
 302   1              
 303   1              f_s32_tmp2 = f_s32_tmp1* 0x80000000;
 304   1              
 305   1              f_s32_tmp3 = floor(f_s32_tmp2);     // ÏòÏÂÈ¡Õû //
 306   1              s32_tmp0 = (INT32S)f_s32_tmp3;  
 307   1              return (s32_tmp0);
 308   1      }
 309          
 310          /*=========================================================================================\n
 311          * @function_name: CalculateAC
 312          * @function_file: EnergyBottom.c
 313          * @ÃèÊö: ½Ç²î¼ÆËã¹«Ê½
 314          * 
 315          * 
 316          * @²ÎÊý: 
 317          * @param:CurValue   £ºµç±í¹¦ÂÊ 
 318          * @param:TarValue   £º±ê×¼±í¹¦ÂÊ
 319          * 
 320          * @·µ»Ø: 
 321          * @return: uint8    
 322          * @×÷Õß:   lwb (2012-06-18)
 323          * @±¸×¢: 
 324          *-------------------------------------------------------------------------------------------
 325          * @ÐÞ¸ÄÈË:  
 326          * @ÐÞ¸ÄÄÚÈÝ: 
 327          ===========================================================================================*/
 328          INT8U CalculateAC(INT32U CurValue,INT32U TarValue)
 329          {
 330   1          //¼ÆËã¹«Ê½¸ü»»,À×ÎÄ±ó£¬2011Äê7ÔÂ14ÈÕ//
 331   1          INT16U Error;                    
 332   1          INT8U Result;
 333   1              INT8U JCFH;
 334   1              
 335   1              JCFH = 0;
 336   1              if(TarValue < 50)   return 0;
 337   1              
 338   1              if(TarValue>CurValue)  
 339   1              {
 340   2                      // ¸ºÎó²î //
 341   2                      Error=(TarValue-CurValue)*1000/TarValue;            //¼ÆËãÎó²îÖµ¡£¡£À©´ó1000
 342   2                      JCFH = 1;
 343   2              }
 344   1              else
 345   1              {
 346   2                      // ÕýÎó²î //
 347   2                      Error=(CurValue-TarValue)*1000/TarValue;            //¼ÆËãÎó²îÖµ¡£¡£À©´ó1000
 348   2              }
 349   1          Result = (INT32U)3011*Error/2000;
 350   1              if(JCFH==1)
 351   1              {
 352   2                      Result|=BIT7;
 353   2              }
 354   1          return Result; 
 355   1      }
 356          
 357          /*********************************************************************************************************
 358          ** º¯ÊýÃû³Æ: SoftAdjust_IB_Process
 359          ** ¹¦ÄÜÃèÊö: Ð£×¼´ó¹¦ÂÊ
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 7   

 360          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ£ºÂö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*10/1000*96
             -*8388608=576716
 361          **           channel: µçÁ÷Í¨µÀ 0-Í¨µÀ1 1-Í¨µÀ2       
 362          ** ³ö¿Ú²ÎÊý: ÎÞ 
 363          ********************************************************************************************************/
 364          void SoftAdjust_IB_Process(uint32 jzval,uint8 channel)
 365          {
 366   1         uint32 val;
 367   1         uint32 adjust_wcval;
 368   1      
 369   1          CLRWDT();
 370   1          if(channel==EMU_CH_L)
 371   1          {
 372   2              val=0;
 373   2              SetMeterCfgACK(val,SCP);  //Ð£Õý¹¦ÂÊÔöÒæ
 374   2              SetMeterCfgACK(val,PARAPC);   
 375   2          }
 376   1          else
 377   1          {
 378   2              val=0;
 379   2              SetMeterCfgACK(val,SCQ);  //Ð£Õý¹¦ÂÊÔöÒæ
 380   2              SetMeterCfgACK(val,PARAQC);   
 381   2          }
 382   1         adjust_wcval=Get_Original_Power(2,channel); 
 383   1         val = CalculateSC(adjust_wcval,jzval);
 384   1         
 385   1          CLRWDT(); 
 386   1          if(channel==EMU_CH_L)
 387   1          {
 388   2              gs_adj_emu_param.w1gain=val;      
 389   2          }
 390   1          else
 391   1          {
 392   2              gs_adj_emu_param.w2gain=val;      
 393   2          }
 394   1          Save_EMU_AdjParam();
 395   1          Check_EMU_AdjParam();
 396   1          CLRWDT();
 397   1      }       
 398          
 399          /*********************************************************************************************************
 400          ** º¯ÊýÃû³Æ: SoftAdjust_IB5_Process
 401          ** ¹¦ÄÜÃèÊö: Ð£×¼Ð¡¹¦ÂÊ
 402          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*0.5/1000*96
             -*8388608=28835
 403          **           channle:µçÁ÷Í¨µÀºÅ 0-Í¨µÀ1  1-Í¨µÀ2
 404          ** ³ö¿Ú²ÎÊý: ÎÞ 
 405          ********************************************************************************************************/
 406          void SoftAdjust_IB5_Process(uint32 jzval,uint8 channel)
 407          {
 408   1         bit Flag_fu=0;   //¸ººÅ±êÖ¾  
 409   1      
 410   1         uint32 val;           
 411   1         uint32 adjust_wcval;
 412   1                    
 413   1      
 414   1          CLRWDT();
 415   1          val=0;
 416   1          if(channel==EMU_CH_L)
 417   1          {
 418   2              SetMeterCfgACK(val,PARAPC);   
 419   2          }
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 8   

 420   1          else
 421   1          {
 422   2              SetMeterCfgACK(val,PARAQC);   
 423   2          }
 424   1         adjust_wcval=Get_Original_Power(3,channel); 
 425   1         val = CalculateAC(adjust_wcval,jzval);
 426   1      
 427   1          CLRWDT(); 
 428   1          if(channel==EMU_CH_L)
 429   1          {
 430   2              gs_adj_emu_param.watt1os=val;      
 431   2          }
 432   1          else
 433   1          {
 434   2              gs_adj_emu_param.watt2os=val;      
 435   2          }
 436   1          Save_EMU_AdjParam();
 437   1          Check_EMU_AdjParam();
 438   1          CLRWDT();
 439   1      
 440   1      }
 441                                  
 442          /*********************************************************************************************************
 443          ** º¯ÊýÃû³Æ: SoftAdjust_Phase_Process
 444          ** ¹¦ÄÜÃèÊö: ¹¦ÂÊÐ£×¼ÏàÎ»
 445          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*5/1000*96*8
             -388608=288358
 446          **           channel£ºÍ¨µÀºÅ
 447          ** ³ö¿Ú²ÎÊý: ÎÞ 
 448          ********************************************************************************************************/
 449          void SoftAdjust_Phase_Process(uint32 jzval,uint8 channel)
 450          {   
 451   1         uint32 val;           
 452   1         uint32 adjust_wcval;
 453   1                    
 454   1      
 455   1          CLRWDT();
 456   1          val=0;
 457   1          if(channel==EMU_CH_L)
 458   1          {
 459   2              SetMeterCfgACK(val,PHCCtrl1);   
 460   2          }
 461   1          else
 462   1          {
 463   2              SetMeterCfgACK(val,PHCCtrl2);   
 464   2          }
 465   1          CLRWDT();
 466   1      
 467   1          gs_emu_adj_var.sec_flg=FALSE;
 468   1          while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 469   1          gs_emu_adj_var.sec_flg=FALSE; 
 470   1      
 471   1         adjust_wcval=Get_Original_Power(2,channel); 
 472   1         val = CalculateAC(adjust_wcval,jzval);
 473   1         
 474   1          CLRWDT(); 
 475   1          if(channel==EMU_CH_L)
 476   1          {
 477   2              gs_adj_emu_param.p1cal=val;      
 478   2          }
 479   1          else
 480   1          {
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 9   

 481   2              gs_adj_emu_param.p2cal=val;      
 482   2          }
 483   1          Save_EMU_AdjParam();
 484   1          Check_EMU_AdjParam();
 485   1          CLRWDT();
 486   1      
 487   1      }
 488                
 489          /*********************************************************************************************************
 490          ** º¯ÊýÃû³Æ: SoftAdjust_dlxProcess      
 491          ** ¹¦ÄÜÃèÊö: Ð£×¼µ÷ÁãÏßÐ£×¼
 492          ** Èë¿Ú²ÎÊý: jzval£ºÀíÂÛ¹¦ÂÊÖµ Âö³å³£Êý/3600*±íÌ¨Êä³ö¹¦ÂÊ/1000*ICONT*8388608 Èç£º1200/3600/220*5/1000*96*8
             -388608=288358
 493          **           channel£ºÍ¨µÀºÅ
 494          ** ³ö¿Ú²ÎÊý: ÎÞ 
 495          ********************************************************************************************************/
 496          void SoftAdjust_dlxProcess(uint32 jzval,uint8 channel)
 497          {
 498   1          uint32 xdata adjust_wcval;
 499   1      
 500   1          CLRWDT();
 501   1          Init_EMU(DLX_MODE);
 502   1          gs_emu_adj_var.sec_flg=FALSE;
 503   1          while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 504   1          gs_emu_adj_var.sec_flg=FALSE; 
 505   1          CLRWDT();
 506   1      
 507   1          gs_emu_adj_var.sec_flg=FALSE;
 508   1          while(gs_emu_adj_var.sec_flg==FALSE);              //ÑÓÊ±1Ãë µÈ´ý¹¦ÂÊÎÈ¶¨
 509   1          gs_emu_adj_var.sec_flg=FALSE;    
 510   1          CLRWDT();
 511   1      
 512   1          if(channel==EMU_CH_L)
 513   1          {
 514   2              //Dis_Adjust(7);                
 515   2              adjust_wcval=Get_Original_Irms(3,EMU_CH_L);             //¶ÁÈ¡AÍ¨µÀÊµ¼Ê µçÁ÷ÓÐÐ§ÖµÊý¾Ý //
 516   2             gs_adj_emu_param.vconst_val_ch1 =((float) jzval)/((float) adjust_wcval);   //»ñÈ¡AÍ¨µÀµÄ³£Êý¼ÆÁ¿ÏµÊ
             -ý //
 517   2          }
 518   1          else
 519   1          {
 520   2              //Dis_Adjust(8);
 521   2              adjust_wcval=Get_Original_Irms(3,EMU_CH_N);   //¶ÁÈ¡BÍ¨µÀÊµ¼Ê µçÁ÷ÓÐÐ§ÖµÊý¾Ý //
 522   2              gs_adj_emu_param.vconst_val_ch2 =((float) jzval)/((float) adjust_wcval);   //»ñÈ¡BÍ¨µÀµÄ³£Êý¼ÆÁ¿Ïµ
             -Êý //
 523   2          }
 524   1      
 525   1          CLRWDT();
 526   1          Init_EMU(NORMAL_MODE);
 527   1          Save_EMU_AdjParam();
 528   1          Check_EMU_AdjParam();
 529   1          NOP();
 530   1          NOP();
 531   1      }
 532          
 533          /*********************************************************************************************************
 534          ** º¯ÊýÃû³Æ: Hardware_AdjustDiv_Sub
 535          ** ¹¦ÄÜÃèÊö: Ó²¼þ¶Ì½Ó Ð£×¼²½ÖèÅÐ¶Ï
 536          ** Èë¿Ú²ÎÊý: ÎÞ
 537          ** ³ö¿Ú²ÎÊý: ÎÞ
 538          ********************************************************************************************************/
 539          void Hardware_AdjustDiv_Sub(void)
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 10  

 540          {
 541   1         uint8 i;
 542   1          uint32 val;
 543   1         uint32 tmpval;
 544   1         uint32 tmpval1=0;     
 545   1         uint32 jzwcval;
 546   1              uint8 ajust_type;
 547   1         uint32 cmp_val[4];
 548   1         uint32 adjust_wcval;
 549   1      
 550   1          if(EA==0)  return;
 551   1      
 552   1          //  ×¼±¸½×¶Î  £¬»ñÈ¡¹¦ÂÊÖµ£¬ÅÐ¶Ï½øÐÐÄÄÒ»²½µÄÐ£±í//
 553   1          gs_emu_adj_var.adj_flg =0x55;   // =0X55 ±êÊ¶Ä¿Ç°½øÈëÐ£±í×´Ì¬ //
 554   1          //Dis_Adjust(99);   //×¼±¸½×¶Î 
 555   1      
 556   1          jzwcval=cst_adj_const.C_PCONST;     // ¶î¶¨¹¦ÂÊµãµÄ¹¦ÂÊÐ£×¼¶¨µãÊý¾Ý//
 557   1          cmp_val[0]=jzwcval*25/10;         //250% IB »ù±¾Ð£±íµã²ÎÊý²ÉÓÃÄ¬ÈÏÖµ³õÊ¼»¯ //
 558   1          cmp_val[1]=jzwcval*70/100;       // »ù±¾µãÐ£×¼ //
 559   1          cmp_val[2]=jzwcval*35/100;       // ½Ç²îÐ£×¼ //
 560   1          cmp_val[3]=jzwcval*3/100;         // Ð¡ÐÅºÅÐ£×¼ //
 561   1      
 562   1          CLRWDT();            
 563   1          adjust_wcval=Get_Original_Power(4,EMU_CH_L);         //¶ÁÈ¡Êµ¼Ê¹¦ÂÊ
 564   1      #if((_METER_TYPE_CFG ==_METER_TYPE_1P2W_1) || (_METER_TYPE_CFG ==_METER_TYPE_1P2W_2)||(_METER_TYPE_CFG ==_
             -METER_TYPE_1P3W_11)  ) 
                  if(adjust_wcval>cmp_val[0])
                  {
                      ajust_type=HARD_EADJ_STEP0_L_INITLIZE;//IB 1.0 ch0;
                  }
                  else if(adjust_wcval>cmp_val[1])
                  {
                      ajust_type=HARD_EADJ_STEP1_L_100IB_100L;//IB 1.0 ch0;
                  }
                  else if(adjust_wcval>cmp_val[2])
                  {
                      ajust_type=HARD_EADJ_STEP2_L_100IB_50L;//IB 0.5 ch0;   
                  }   
                  else if(adjust_wcval>cmp_val[3])
                  {
                      ajust_type=HARD_EADJ_STEP3_L_5IB_100L;//5%IB 1.0 ch0;   
                  }
                  else
                  {
                      adjust_wcval=Get_Original_Power(4,EMU_CH_N);     //¶ÁÈ¡Êµ¼Ê¹¦ÂÊ
                      if(adjust_wcval>cmp_val[0])
                      {
                          ajust_type=HARD_EADJ_STEP4_N_INITLIZE;//IB 1.0 ch0;
                      }
                      else if(adjust_wcval>cmp_val[1])
                      {
                          ajust_type=HARD_EADJ_STEP5_N_100IB_100L;//IB 1.0 ch1;
                      }
                      else if(adjust_wcval>cmp_val[2])
                      {
                          ajust_type=HARD_EADJ_STEP6_N_100IB_50L;//IB 0.5 ch1;     
                      }   
                      else if(adjust_wcval>cmp_val[3])
                      {
                          ajust_type=HARD_EADJ_STEP7_N_5IB_100L;//5%IB 1.0 ch1;   
                      }
                      else
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 11  

                      {
                          ajust_type=HARD_EADJ_STEP8_METER_CLR;// µç±íÇåÁã  //   
                      }
                  }
              #endif
 606   1      
 607   1      #if((_METER_TYPE_CFG ==_METER_TYPE_1P2W_0)  ) 
 608   1          if(adjust_wcval>cmp_val[0])
 609   1          {
 610   2              ajust_type=HARD_EADJ_STEP0_L_INITLIZE;//IB 1.0 ch0;
 611   2          }
 612   1          else if(adjust_wcval>cmp_val[1])
 613   1          {
 614   2              ajust_type=HARD_EADJ_STEP1_L_100IB_100L;//IB 1.0 ch0;
 615   2          }
 616   1          else if(adjust_wcval>cmp_val[2])
 617   1          {
 618   2              ajust_type=HARD_EADJ_STEP2_L_100IB_50L;//IB 0.5 ch0;   
 619   2          }   
 620   1          else if(adjust_wcval>cmp_val[3])
 621   1          {
 622   2              ajust_type=HARD_EADJ_STEP3_L_5IB_100L;//5%IB 1.0 ch0;   
 623   2          }
 624   1          else
 625   1          {
 626   2               ajust_type=HARD_EADJ_STEP8_METER_CLR;// µç±íÇåÁã  //   
 627   2          }
 628   1      #endif
 629   1      
 630   1          //   ·Ö²½ÖèÐ£×¼´¦Àí   //
 631   1          //  HARD_EADJ_STEP0_L_INITLIZE   L»ØÂ·±È²î¼Ä´æÆ÷³õÊ¼»¯//
 632   1          if(ajust_type==HARD_EADJ_STEP0_L_INITLIZE)
 633   1          {                      
 634   2              gs_adj_emu_param.w1gain = 0;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
 635   2              Save_EMU_AdjParam();
 636   2              Check_EMU_AdjParam();
 637   2              CLRWDT();
 638   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_0);   // Òº¾§ÏÔÊ¾ //
 639   2          }
 640   1      
 641   1          //  HARD_EADJ_STEP1_L_100IB_100L   L»ØÂ·100%Ib, 1.0L Ð£×¼//
 642   1          if(ajust_type==HARD_EADJ_STEP1_L_100IB_100L)
 643   1          {                      
 644   2              //Dis_Adjust(1);  
 645   2              // L»ØÂ·ÓÐ¹¦ÔöÒæÐ£×¼ // 
 646   2              SoftAdjust_IB_Process(jzwcval,EMU_CH_L); 
 647   2      
 648   2              // L»ØÂ·µçÁ÷ÓÐÐ§ÖµÔöÒæÐ£×¼ //   
 649   2              tmpval=0;
 650   2              for(i=0;i<8;i++)
 651   2              {
 652   3                  Lib_Delay_ms(30);
 653   3                  val = ReadMeterParaACK(RMSII1);
 654   3                  if(val>=0x80000000)
 655   3                  {
 656   4                      val=~val+1;  
 657   4                  }                           
 658   3                  tmpval=tmpval+val;
 659   3                  CLRWDT();          
 660   3              }
 661   2              tmpval=tmpval/8;
 662   2              //µçÁ÷ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.I_refºÍ»ù±¾µçÁ÷ÕûÊýµÄ±¶Êý//
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 12  

 663   2              gs_adj_emu_param.i1rms_xs=(float)cst_adj_const.I_ref/(float)tmpval;  
 664   2              //µçÑ¹ÓÐÐ§ÖµÔöÒæÐ£×¼ //                         
 665   2              tmpval=0;
 666   2              for(i=0;i<8;i++)
 667   2              {
 668   3                  Lib_Delay_ms(30);
 669   3                  val = ReadMeterParaACK(RMSIU);
 670   3                  if(val>=0x80000000)
 671   3                  {
 672   4                      val=~val+1;  
 673   4                  }                           
 674   3                  tmpval=tmpval+val;
 675   3                  CLRWDT();        
 676   3              }
 677   2              tmpval=tmpval/8;      
 678   2              //µçÑ¹ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.U_refºÍ»ù±¾µçÑ¹ÕûÊýµÄ±¶Êý//
 679   2              gs_adj_emu_param.vrms_xs=(float)cst_adj_const.U_ref/(float)tmpval;  
 680   2      
 681   2      #if( (_METER_TYPE_CFG ==_METER_TYPE_1P2W_2) ) 
                      // L»ØÂ·µôÁãÏßµçÑ¹³£Á¿Ð£×¼//  
                      CLRWDT();            
                      //Dis_Adjust(99);   //×¼±¸½×¶Î    
                      SoftAdjust_dlxProcess(jzwcval,EMU_CH_L);
              #endif
 687   2      
 688   2              Save_EMU_AdjParam();
 689   2              Check_EMU_AdjParam();
 690   2              CLRWDT();
 691   2                      
 692   2                api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_1);   // Òº¾§ÏÔÊ¾ //
 693   2          }
 694   1      
 695   1          //  HARD_EADJ_STEP2_L_100IB_50L   L»ØÂ·100%Ib, 0.5L Ð£×¼//
 696   1          if(ajust_type==HARD_EADJ_STEP2_L_100IB_50L)
 697   1          {                            
 698   2              //Dis_Adjust(2);
 699   2              jzwcval=jzwcval/2;
 700   2              SoftAdjust_Phase_Process(jzwcval,EMU_CH_L);  
 701   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_2);   // Òº¾§ÏÔÊ¾ //
 702   2          }
 703   1          //  HARD_EADJ_STEP3_L_5IB_100L   L»ØÂ·5%Ib, 1.0L Ð£×¼//
 704   1          if(ajust_type==HARD_EADJ_STEP3_L_5IB_100L)
 705   1          {                            
 706   2              //Dis_Adjust(3);
 707   2              jzwcval=jzwcval/20;
 708   2              SoftAdjust_IB5_Process(jzwcval,EMU_CH_L);   
 709   2              api_chg_LCDDisplay_adj_item(DIS_ADJ_CH1_3);   // Òº¾§ÏÔÊ¾ //   
 710   2          }
 711   1      
 712   1      #if((_METER_TYPE_CFG ==_METER_TYPE_1P2W_1) || (_METER_TYPE_CFG ==_METER_TYPE_1P2W_2)||(_METER_TYPE_CFG ==_
             -METER_TYPE_1P3W_11)  ) 
                  //  HARD_EADJ_STEP4_N_INITLIZE   N»ØÂ·±È²î¼Ä´æÆ÷³õÊ¼»¯//
                  if(ajust_type==HARD_EADJ_STEP4_N_INITLIZE)
                  {                      
                      gs_adj_emu_param.w2gain = 0;   //³õÊ¼»¯L1Í¨µÀ±È²î¼Ä´æÆ÷  //
                      Save_EMU_AdjParam();
                      Check_EMU_AdjParam();
                      CLRWDT();
                      api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_0);   // Òº¾§ÏÔÊ¾ //
                  }
              
                  //  HARD_EADJ_STEP4_N_100IB_100L   N»ØÂ·100%Ib, 1.0L Ð£×¼//
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 13  

                  if(ajust_type==HARD_EADJ_STEP5_N_100IB_100L)
                  {              
                      //Dis_Adjust(1);  
                      // L»ØÂ·ÓÐ¹¦ÔöÒæÐ£×¼ // 
                      SoftAdjust_IB_Process(jzwcval,EMU_CH_N); 
              
                      // L»ØÂ·µçÁ÷ÓÐÐ§ÖµÔöÒæÐ£×¼ //   
                      tmpval=0;
                      for(i=0;i<8;i++)
                      {
                          Lib_Delay_ms(30);
                          val = ReadMeterParaACK(RMSII2);
                          if(val>=0x80000000)
                          {
                              val=~val+1;  
                          }                           
                          tmpval=tmpval+val;
                          CLRWDT();          
                      }
                      tmpval=tmpval/8;
                      //µçÁ÷ÓÐÐ§ÖµµÄÎ»ÊýÔÚ´Ë´¦¾ö¶¨£¬È¡¾öÓÚcst_adj_const.I_refºÍ»ù±¾µçÁ÷ÕûÊýµÄ±¶Êý//
                      gs_adj_emu_param.i2rms_xs=(float)cst_adj_const.I_ref/(float)tmpval;  
              
              #if( (_METER_TYPE_CFG ==_METER_TYPE_1P2W_2) ) 
                      // N»ØÂ·µôÁãÏßµçÑ¹³£Á¿Ð£×¼//  
                      CLRWDT();            
                      //Dis_Adjust(99);   //×¼±¸½×¶Î    
                      SoftAdjust_dlxProcess(jzwcval,EMU_CH_N);
              #endif
              
                      Save_EMU_AdjParam();
                      Check_EMU_AdjParam();
                      CLRWDT();
                      api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_1);   // Òº¾§ÏÔÊ¾ //            
                  }
              
                  //  HARD_EADJ_STEP6_N_100IB_50L   N»ØÂ·100%Ib, 0.5L Ð£×¼//
                  if(ajust_type==HARD_EADJ_STEP6_N_100IB_50L)
                  {                      
                      //Dis_Adjust(5);
                      jzwcval=jzwcval/2;
                      SoftAdjust_Phase_Process(jzwcval,EMU_CH_N);  
                      api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_2);   // Òº¾§ÏÔÊ¾ //
                  }    
                  //  HARD_EADJ_STEP7_N_5IB_100L   N»ØÂ·5%Ib, 1.0L Ð£×¼//
                  if(ajust_type==HARD_EADJ_STEP7_N_5IB_100L)
                  {                         
                      //Dis_Adjust(6);
                      jzwcval=jzwcval/20;
                      SoftAdjust_IB5_Process(jzwcval,EMU_CH_N);   
                      api_chg_LCDDisplay_adj_item(DIS_ADJ_CH2_3);   // Òº¾§ÏÔÊ¾ //   
                  }
              #endif
 777   1      
 778   1          if(ajust_type==HARD_EADJ_STEP8_METER_CLR)
 779   1          {        
 780   2              Proc_clr_meter();
 781   2              api_chg_LCDDisplay_adj_item(DIS_DATA_CLR);   // Òº¾§ÏÔÊ¾ //
 782   2          }
 783   1      
 784   1          gs_emu_adj_var.adj_flg =0;   // =0X0 ±êÊ¶Ä¿Ç°ÍË³öÐ£±í×´Ì¬ //        
 785   1      
C51 COMPILER V9.01   LNK_EMU_ADJ                                                           01/31/2019 11:34:22 PAGE 14  

 786   1      }
 787          
 788          
 789          /*******************************************************************************************
 790          **    END
 791          *******************************************************************************************/
 792          
 793          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3798    ----
   CONSTANT SIZE    =    138    ----
   XDATA SIZE       =     56     159
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
